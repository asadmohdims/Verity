ðŸ“˜ VERITY â€“ CORE SEED
Authoritative Loading Capsule
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Purpose:
This seed reinitializes the complete philosophical and architectural foundation of Verity.
It never changes unless the global constitution changes.
All other seeds (Operational, Feature, UX, Testing, Phase) must inherit from this one.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0. Identity
App Name: Verity
Essence: Truth Â· Correctness Â· Clarity Â· Trust
Tone: Professional Â· Modern Â· Calm (not flashy or enterprise gray)
Goal: A long-term, daily-use modern Android billing app.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Foundational Philosophy (Frozen)
â€¢ Architecture, UX, and correctness matter more than speed.
â€¢ Compose-first, Kotlin-first, Testable, Scalable.
â€¢ Offline-first â€” Cloud is a sync target, never the source of truth.
â€¢ Deterministic, rebuildable projections.
â€¢ Explicit domain events â€” no silent mutations.
â€¢ Immutability as default â€” invoices, payments, and ledger are never mutated post-finalization.
â€¢ Testing is first-class; nothing is too small to test.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2. Multi-Organization Law (Locked)
â€¢ Must support multiple organizations (not hard-coded for Unitech Machineries).
â€¢ Branding, logo, and tax metadata must be configurable via templates.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3. Architecture & Structure (Locked)
Top-level packages (ONLY THESE):
    app/
    core/
    features/
    platform/

app/
    â€¢ Application entry, NavHost, DI wiring â€” no business logic.

core/
    â€¢ theme (colors, typography, motion tokens)
    â€¢ ui (primitives, atoms, molecules only)
    â€¢ navigation (destinations, routes)
    â€¢ formatting (money, dates)
    â€¢ utils, result types
    â€¢ no feature knowledge.

features/
    â€¢ each feature isolated â€” Invoice, Search, Customers, Ledger, Payments.
    â€¢ communication only via navigation contracts or IDs.
    â€¢ no shared UI, ViewModels, or repositories.

platform/
    â€¢ database (Room + KSP)
    â€¢ cloud (Firebase/APIs)
    â€¢ workers (WorkManager)
    â€¢ device helpers and permissions.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4. Core Domain Model (Immutable)
â€¢ Invoices = Events
â€¢ Payments = Events
â€¢ Customers = Identities
â€¢ Ledger = Deterministic projection (Invoices â†’ Debits; Payments â†’ Credits)

Rules:
    - Invoices immutable once finalized.
    - Payments always positive, immutable, and reversible only via new entries.
    - Ledger rebuildable and read-only.
    - Negative balance = Customer credit (advance).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5. UI & UX Foundations
â€¢ Compose-first; XML forbidden.
â€¢ Invoice creation = default primary action.
â€¢ Search is deliberate, not ambient.
â€¢ Fast-entry UX for power users is mandatory.
â€¢ Preview-before-finalize is mandatory.
â€¢ Ledger explains truth; it never edits it.
â€¢ Payments are explicit, never automatic.
â€¢ Motion can acknowledge change but never carry meaning.
â€¢ Immutability is a user-facing principle â€” truth over illusion.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6. Coding Interaction Rules (Critical)
1. Do not assume new methods, classes, or imports.
2. Ask first if something is missing.
3. Work on one file at a time.
4. No refactors unless explicitly requested.
5. Explain reasoning before writing code.
6. Prefer minimal, reversible changes.
Violation = stop and reassess.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7. Testing & Reliability
â€¢ Each module and feature independently testable.
â€¢ Explicit migrations required for all Room changes.
â€¢ Ledger rebuildability tested as invariant.
â€¢ No Firebase listeners or remote triggers in UI layer.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
8. Stack (Locked)
Jetpack Compose Â· Material 3 (tokens only) Â· Navigation-Compose Â·
ViewModel + StateFlow Â· Room + KSP Â· Coroutines Â· WorkManager Â· Hilt Â· Gradle Version Catalogs

Forbidden: XML Â· Fragments Â· LiveData Â· AsyncTask Â· RxJava Â· EventBus Â· DataBinding Â· Legacy Material 2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
9. Global UX Laws (Frozen)
1. Invoice creation is default action.
2. Search is deliberate, not ambient.
3. Ledger explains truth; never edits.
4. Payments explicit; never automatic.
5. Preview-before-finalize mandatory.
6. Fast-entry UX is first-class.
7. Immutability is default.
8. Search context always visible & resettable.
9. Secondary info never steals focus.
10. Every screen must be wireframed before code.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10. Coding Assistant Behaviour
This capsule defines Verityâ€™s law.
Any derived seed (operational, feature, or UX) inherits these rules.
If any ambiguity arises, stop and request clarification before proceeding.
