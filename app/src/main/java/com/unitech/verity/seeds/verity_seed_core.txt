ðŸ“˜ VERITY â€“ CORE SEED

Authoritative Loading Capsule (Amended & Strengthened)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose

This seed reinitializes the complete philosophical and architectural foundation of Verity.
It never changes unless the global constitution changes.
All other seeds (Operational, Feature, UX, Testing, Phase) must inherit from this one.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

0. Identity

App Name: Verity
Essence: Truth Â· Correctness Â· Clarity Â· Trust
Tone: Professional Â· Modern Â· Calm (not flashy or enterprise gray)
Goal: A long-term, daily-use modern Android billing app.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Foundational Philosophy (Frozen)

â€¢ Architecture, UX, and correctness matter more than speed.
â€¢ Compose-first, Kotlin-first, testable, scalable.
â€¢ Offline-first â€” local database is the sole source of truth; cloud is a replication and recovery target only.
â€¢ Explicit domain events â€” append-only; no silent mutations.
â€¢ All mutable state is derived from events, never edited in place.
â€¢ Deterministic, rebuildable projections (state must be reproducible from history).
â€¢ Immutability by default â€” invoices, payments, and ledger are never mutated post-finalization.
â€¢ Testing is first-class; domain invariants are enforced through tests, not convention.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1A. Domain Causality Laws (Frozen)

â€¢ Commands ask permission.
â€¢ Aggregates decide truth.
â€¢ Events record history.
â€¢ Aggregates create history.
â€¢ Replay interprets history.
â€¢ Projections explain results.
â€¢ Projections present results.
â€¢ No projection is authoritative; deleting any projection must never destroy truth.

Violation of any law is an architectural defect and must stop development until resolved.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

2. Multi-Organization Law (Locked)

â€¢ Must support multiple organizations (not hard-coded for Unitech Machineries).
â€¢ Branding, logo, and tax metadata must be configurable via templates.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

3. Architecture & Structure (Locked)

Top-level packages (ONLY THESE):

app/
core/
features/
platform/

app/
â€¢ Application entry, NavHost, DI wiring â€” no business logic.

core/
â€¢ theme (colors, typography, motion tokens)
â€¢ ui (primitives, atoms, molecules only)
â€¢ navigation (destinations, routes)
â€¢ formatting (money, dates)
â€¢ utils, result types
â€¢ no feature knowledge.

features/
â€¢ Each feature isolated â€” Invoice, Search, Customers, Ledger, Payments.
â€¢ Communication only via navigation contracts or IDs.
â€¢ No shared UI, ViewModels, or repositories.

platform/
â€¢ database (Room + KSP)
â€¢ cloud (Firebase / APIs)
â€¢ workers (WorkManager)
â€¢ device helpers and permissions.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4. Core Domain Model (Immutable)

â€¢ Invoices = Events
â€¢ Payments = Events
â€¢ Customers = Identities
â€¢ Ledger = Deterministic projection
(Invoices â†’ Debits; Payments â†’ Credits)

Rules:
	â€¢	Invoices immutable once finalized.
	â€¢	Payments always positive, immutable, and reversible only via new entries.
	â€¢	Ledger is read-only and fully rebuildable from events.
	â€¢	Negative balance represents customer credit (advance), never negative payments.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4A. Immutability Laws (Frozen)

â€¢ The events table is append-only.
â€¢ No event may be updated, deleted, or rewritten.
â€¢ All corrections are represented by new compensating events.
â€¢ No migration may alter the meaning of historical events.
â€¢ Projections and drafts are disposable; events are not.
â€¢ Replay is the only valid mechanism to derive state from history.

Any attempt to bypass immutability is a correctness violation.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4B. Aggregate Boundaries (Frozen)

Verity uses explicit aggregate boundaries to enforce correctness and prevent cross-domain mutation.
An aggregate is the smallest unit that enforces its own invariants and emits its own domain events.

Authoritative aggregate list (Phase 5):

â€¢ Customer
  - Identity: customerId
  - Responsibility: customer lifecycle and non-financial metadata

â€¢ Invoice
  - Identity: invoiceId
  - Responsibility: financial debit (service or sale)
  - Emits: InvoiceFinalized, InvoiceCancelled

â€¢ Challan
  - Identity: challanId
  - Responsibility: goods custody / logistical truth
  - Emits: ChallanIssued, ChallanCancelled

â€¢ Payment
  - Identity: paymentId
  - Responsibility: financial credit
  - Emits: PaymentRecorded, PaymentReversed

â€¢ DocumentRelationship
  - Identity: relationshipId
  - Responsibility: explicit, auditable linkage between domain documents
  - Emits: DocumentsLinked (and compensating unlink events if introduced later)

Rules:
â€¢ Aggregates validate commands and decide truth.
â€¢ Aggregates must never read or mutate other aggregates.
â€¢ Cross-aggregate coordination is expressed only via events and references.
â€¢ Ledger, balances, statuses, jobs, drafts, and summaries are NOT aggregates; they are projections or workflow state.

Changing aggregate boundaries requires an explicit constitutional amendment.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

5. UI & UX Foundations (Frozen)

â€¢ Compose-first; XML forbidden.
â€¢ Invoice creation is the default primary action.
â€¢ Search is deliberate, not ambient.
â€¢ Fast-entry UX for power users is mandatory.
â€¢ Preview-before-finalize is mandatory.
â€¢ Ledger explains truth; it never edits it.
â€¢ Payments are explicit, never automatic.
â€¢ Motion may acknowledge change but must never carry meaning.
â€¢ Immutability is a user-facing principle â€” truth over illusion.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

6. Coding Interaction Rules (Critical)
	1.	Do not assume new methods, classes, or imports.
	2.	Ask first if something is missing.
	3.	Work on one file at a time.
	4.	No refactors unless explicitly requested.
	5.	Explain reasoning before writing code.
	6.	Prefer minimal, reversible changes.

Violation = stop and reassess.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

7. Testing & Reliability

â€¢ Each module and feature independently testable.
â€¢ Explicit migrations required for all Room schema changes.
â€¢ Ledger rebuildability tested as a non-negotiable invariant.
â€¢ Domain invariants must have tests before features rely on them.
â€¢ No Firebase listeners or remote triggers in the UI layer.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

7A. Projection Laws (Frozen)

â€¢ Projections are performance optimizations, never sources of truth.
â€¢ All projections must be fully rebuildable from events.
â€¢ Projections may lag behind events but must converge deterministically.
â€¢ UI and business logic must never mutate projections directly.
â€¢ If projections disagree with events, events always win.
â€¢ Loss or corruption of a projection must not cause data loss.

Projection correctness is enforced through replay-based tests.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

8. Stack (Locked)

Jetpack Compose Â· Material 3 (tokens only) Â· Navigation-Compose Â·
ViewModel + StateFlow Â· Room + KSP Â· Coroutines Â· WorkManager Â·
Hilt Â· Gradle Version Catalogs

Forbidden:
XML Â· Fragments Â· LiveData Â· AsyncTask Â· RxJava Â· EventBus Â·
DataBinding Â· Legacy Material 2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

9. Global UX Laws (Frozen)
	1.	Invoice creation is the default action.
	2.	Search is deliberate, not ambient.
	3.	Ledger explains truth; never edits.
	4.	Payments explicit; never automatic.
	5.	Preview-before-finalize mandatory.
	6.	Fast-entry UX is first-class.
	7.	Immutability is default.
	8.	Search context always visible and resettable.
	9.	Secondary information never steals focus.
	10.	Every screen must be wireframed before code.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

10. Coding Assistant Behaviour

This capsule defines Verityâ€™s law.
Any derived seed (operational, feature, UX, or testing) inherits these rules.
If ambiguity arises, stop and request clarification before proceeding.

â¸»
