# VERITY – OPERATIONAL SEED
Inherits from: verity_seed_core.txt
──────────────────────────────────────
PROJECT PHASE MODEL (AUTHORITATIVE)

FOUNDATION PHASES — COMPLETED & LOCKED
• F0 — Reset & Intent ✅
• F1 — Business & Domain Fundamentals ✅
• F2 — Architecture Blueprint ✅
• F3 — UX Laws, Design System & Wireframes ✅
• F4 — Core Implementation Foundations ✅ (LOCKED)

DELIVERY PHASES — IN PROGRESS
• D1 — Invoice Workspace (UI-only, read-only) ✅ COMPLETED & LOCKED
• D2 — Core Workflows (Invoices & Challans) ▶️ ACTIVE
• D3 — Experience, Sync & Production ▶️ UPCOMING

──────────────────────────────────────
Current Focus:
Foundation is complete and constitutionally locked.
The project is transitioning from platform correctness
to visible product delivery.

Toolchain Status (Operational, Confirmed)

• Kotlin 2.x baseline is active and verified via successful build.
• Compose Compiler is applied via the official Kotlin Compose Compiler Plugin.
• Kotlinx Serialization is enabled and validated in the platform module.
• No forced dependency resolution is in use.
• Toolchain is considered stable for D2 execution.

──────────────────────────────────────
D1 — Invoice Workspace (Operational Clarifications)

The Invoice Workspace is the default landing surface in D1 and is treated
as a working desk, not a document viewer.

Operational intent for D1:

• Workspace UI is read‑only but must be structurally complete and domain‑true.
• UI reflects real GST invoice mental flow before interaction is introduced.
• No PDF viewing, printing, or finalization in D1.
• Summary is informational only; terminal gravity is deferred to D2.
• Search is a distinct mode and must be visibly accessible from the Workspace
  at all times.
• Customer selection, line items, logistics, and summary are staged for
  interaction but remain non‑interactive in D1A.

Explicit exclusions in D1:

• No input atoms or autocomplete behaviour.
• No mutation, commands, or draft persistence.
• No challan creation or linkage actions (conceptual slots only).
• No navigation beyond Workspace ↔ Search Mode.


D1 Status:
• D1A — Invoice Workspace layout, semantics, and visual structure are complete and locked.
• D1B — Parties and Line Item backbone validated conceptually and locked.
• D1 introduced no mutation paths and preserved full read-only guarantees.
• D1 is formally complete; no further work may be added to D1.

──────────────────────────────────────
D2 — Core Workflows (Operational Clarifications)

D2 introduces interactive draft creation while preserving all domain, replay, and projection laws.
Drafts are explicitly UI-only workflow state and are not domain truth.

D2.1 — Draft Spine (COMPLETE & LOCKED)
• In-memory, single-draft model owned by a Draft Store.
• Draft mutation flows exclusively through Draft Store APIs.
• Draft Reducers remain pure and side-effect free.
• ViewModels coordinate intent but contain no business rules.
• Draft UI State is disposable and never persisted as domain truth.

D2.2 — Atom-by-Atom UI Enablement (ACTIVE)

D2.2.A — Atom Inventory (Authoritative for D2)

This section enumerates all draft input atoms planned for D2 execution.
Atoms are implemented sequentially and locked once validated end-to-end.

Planned Atoms:

• Atom 1 — Billed To (Customer selection)
  – Customer autocomplete (CRUD-backed, read-only)
  – Draft mutation: billedTo
  – Status: COMPLETE & LOCKED

• Atom 2 — Shipped To (Override from Billed To)
  – Defaults to billedTo when unset
  – Tap-to-edit affordance (no explicit “Change” action)
  – Draft mutation: shippedTo (explicit override only)
  – Status: IN PROGRESS

• Atom 3 — Line Items
  – Add / edit / remove draft line items
  – Quantity, rate, HSN, unit
  – Draft mutation: lineItems[]
  – Status: PLANNED

• Atom 4 — Logistics & Freight
  – Transport details, freight amount, supply date
  – Draft mutation: transportDetails, additionalDetails
  – Status: PLANNED

• Atom 5 — Summary (Derived)
  – Subtotal, tax, grand total
  – Read-only derived view from draft state
  – No direct mutation
  – Status: PLANNED

• Atom 6 — Pre-finalization Preview
  – Read-only authoritative PDF preview
  – Gate before finalization
  – Status: PLANNED

• Atom 1 — Billed To (Customer selection):
  – Draft mutation path implemented via Draft Store.
  – Read path defined via CustomerAutocompleteDataSource (CRUD-backed).
  – Data source reads from a designated read-only Customer CRUD table.
  – ViewModel wiring complete; no replay or projection dependency.
  – Subsequent atoms (Shipped To, Line Items, Freight, Summary) are gated behind Atom 1 completion.
  – Atom 1 is considered complete once UI → ViewModel → Draft Store wiring is functional and visible on screen.

Deferred UX Optimization — Autocomplete & Input Interactions (Recorded)

The following UX issues have been consciously observed during Atom 1
end-to-end testing and are intentionally deferred until all input-heavy
atoms are structurally complete.

Observed Issues:
• Keyboard dismisses when autocomplete suggestions appear.
• Focus is lost during query → results transition.
• Dropdown layout interaction feels jumpy on mobile.
• Interaction rhythm between typing and selection is suboptimal.

Deferral Rationale:
• Autocomplete UX depends on final focus and keyboard strategy.
• Multiple additional input atoms (Shipped To, Line Items, Freight, Notes)
  are pending and would invalidate premature tuning.
• UX optimization will be performed once all draft input atoms exist.

Planned Resolution Window:
• Dedicated UX optimization pass scheduled after Atom 4 (Line Items entry)
  and before any PDF preview, finalization, or production hardening work.

Explicit Exclusions in D2:
• No invoice finalization or numbering.
• No authoritative PDF generation (preview-only semantics deferred).
• No cloud sync enablement.
• No multi-draft support.
• No event-sourced customer lifecycle or customer projections in D2.

──────────────────────────────────────
CANONICAL NAVIGATION FLOW (OPERATIONAL, LOCKED)

The application follows a task‑first navigation topology.
This topology is authoritative and must not be re‑routed.
Delivery phases may gate nodes, but must not alter topology.

Default Entry
• App launch lands in Invoice / Challan Workspace (draft‑first).

Primary Modes
• Invoice / Challan Workspace — creation and drafting workspace.
• Search Mode — dedicated recall, comparison, and reuse space.
• Customers — relationship and money management.

Canonical Transitions
• Workspace → Search Mode (explicit user intent).
• Search Mode → Open Document (read‑only snapshot; PDF view deferred to D2).
• Search Mode → Create from existing → Workspace (new draft; gated until D2).
• Workspace → Customers.
• Customers → Add Payment → Customer Ledger.
• Customer Ledger → Open Document (read‑only).
• Back navigation always returns to the originating context.

Document Viewing Law
• Documents are immutable once finalized.
• In D1, documents may be opened only as read‑only data snapshots.
• Authoritative PDF generation occurs only after finalization (D2+).
• All finalized documents are rendered via a single read‑only PDF viewer.
• Documents are never edited in place after finalization.

──────────────────────────────────────
DOCUMENT LINKAGE (INVOICE ↔ CHALLAN) — OPERATIONAL, LOCKED

• Invoices and Challans are independent, immutable documents.
• Linking between documents is explicit and event‑driven.
• Linking never mutates existing documents; it creates new facts.
• One Invoice may link to one or more Challans.
• A Challan may link to at most one Invoice.
• Document linkage is derived into projections for navigation only.
• Linkage must always be visible in search and document views once activated.
• Creation of linkage is gated until D2 workflows.

──────────────────────────────────────
Scope:
• Domain-first design (events, invariants, projections).
• Local database (Room) as the sole source of truth.
• Explicit migrations before schema changes.
• Offline-first sync design (cloud as replication target only).
• Test-first enforcement of domain invariants.
• No speculative UI or UX changes.
• Event Sourcing applied surgically to financial and logistical domain truth only.
• Supporting identity data (e.g. Customers) is managed via CRUD where appropriate.
• Projections treated strictly as rebuildable performance caches.
• Replay-first design with incremental (delta-based) rebuilds for scalability.
• Version-catalog–driven dependency management (no ad-hoc plugin or library versions).
• Platform module is the exclusive owner of persistence technologies (Room, KSP).
• Financial ledger projection pipeline (map → replay → project) implemented and test‑backed.
• Document Index projection pipeline (map → replay → project) implemented and test‑backed.
• PlatformReplayCoordinator is the sole entry point for invoking projection replay and rebuilds.
• Draft workflow state is UI-only, disposable, and excluded from persistence, replay, and sync.

──────────────────────────────────────
Current Working Components:
core/domain/
    ├─ events (Invoice, Payment)
    ├─ invariants (ledger, balance, immutability rules)

platform/database/
    ├─ Room entities & DAOs
    ├─ Explicit migrations (versioned, tested)
    ├─ EventEntity (append-only event store)
    ├─ LedgerBalanceEntity (rebuildable ledger projection)
    ├─ LedgerBalanceDao (projection-only persistence)
    ├─ LedgerProjectionWriter (incremental replay orchestration)
    ├─ DocumentIndexEntity (search/navigation projection)
    ├─ DocumentIndexDao (projection-only persistence)
    ├─ DocumentIndexProjectionWriter (incremental & full replay orchestration)
    ├─ KSP-backed Room configuration (platform-only)
    ├─ CustomerEntity (CRUD-managed customer identity table)
    ├─ CustomerDao (CRUD persistence & read-only queries)

platform/cloud/
    ├─ Sync boundaries & replication logic (no UI coupling)

tests/
    ├─ Domain invariant tests
    ├─ Ledger rebuild tests
    ├─ Migration tests
    ├─ LedgerProjectionWriter tests
    ├─ DocumentIndexProjectionWriter tests

core/replay/
    ├─ Pure replay engine (events → LedgerState)
    ├─ LedgerState (balances + audit entries)
    ├─ DocumentIndexState (canonical document index view)
    ├─ DocumentIndexReplayEngine (pure replay from mutations)
platform/replay/
    ├─ PlatformReplayCoordinator (canonical replay entry point)
    ├─ DefaultPlatformReplayCoordinator (Phase‑1 implementation)
    ├─ PlatformReplayableEvent (event adapter)

feature/invoice/draft/
    ├─ InvoiceDraftUiState (UI-only draft model)
    ├─ InvoiceDraftReducer (pure draft transformations)
    ├─ InvoiceDraftStore (in-memory draft owner)

feature/invoice/ui/
    ├─ InvoiceWorkspaceViewModel (draft orchestration + read/write separation)

feature/invoice/autocomplete/
    ├─ CustomerAutocompleteDataSource (read-only CRUD adapter)

──────────────────────────────────────
Operational Laws (Frozen for Foundation Phases)
• Local database is the single source of truth.
• All financial and document state changes occur via append-only domain events.
• Supporting identity data may change via explicit CRUD within defined boundaries.
• Projections must be fully rebuildable from events.
• No silent data mutation or in-place edits.
• Migrations are mandatory and written before schema changes.
• UI may not compensate for data inconsistency.
• Cloud sync may lag, replay, or fail without corrupting truth.
• Commands express intent; only aggregates may emit domain events.
• Replay explains history; it must never decide or mutate truth.
• Projection tables may be dropped and rebuilt at any time without data loss.
• Performance optimizations must not introduce new sources of truth.
• Build configuration errors are correctness failures, not tooling issues.
• Room, KSP, and migrations must never appear outside the platform module.
• Event storage schema changes require migration tests before merge.
• Projection writers must never be invoked directly outside the PlatformReplayCoordinator.
• Replay execution order is deterministic and centrally enforced.
• Introduction of alternate replay entry points is a constitutional violation.

──────────────────────────────────────
Behavioural Laws for the Assistant:
• Always confirm invariants before proposing data models.
• No Room entities without migration strategy.
• No sync logic without failure and replay semantics.
• Prefer tests and invariants before feature code.
• Stop immediately if correctness is compromised.

──────────────────────────────────────
Current Deliverables (as of Foundation completion):
• Event store (EventEntity + EventDao) locked and tested for replay safety.
• Financial event mapping layer enforced with fail‑loud semantics.
• Deterministic ledger replay engine producing LedgerState.
• Incremental ledger projection writer with embedded cursor strategy.
• Rebuildable ledger balance projection persisted via Room.
• JVM tests covering replay, projection, and failure scenarios.
• Deterministic Document Index replay engine deriving canonical document state.
• Incremental, cursor‑driven Document Index projection writer (idempotent & crash‑safe).
• Rebuildable document index projection persisted via Room.
• JVM tests covering Document Index replay, projection, and failure semantics.
• PlatformReplayCoordinator implemented as the single canonical replay entry point.
• Ledger and Document Index projection writers normalized to a common invocation contract.
