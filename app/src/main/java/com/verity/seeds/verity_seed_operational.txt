# VERITY – OPERATIONAL SEED
Inherits from: verity_seed_core.txt
──────────────────────────────────────
PROJECT PHASE MODEL (AUTHORITATIVE)

FOUNDATION PHASES — COMPLETED & LOCKED
• F0 — Reset & Intent ✅
• F1 — Business & Domain Fundamentals ✅
• F2 — Architecture Blueprint ✅
• F3 — UX Laws, Design System & Wireframes ✅
• F4 — Core Implementation Foundations ✅ (LOCKED)

DELIVERY PHASES — IN PROGRESS
• D1 — Invoice Workspace (Read-only semantics) ✅ COMPLETED & LOCKED
• D2 — Draft Creation & Core Workflows ▶️ ACTIVE
• D3 — Experience, Sync & Production ▶️ UPCOMING

──────────────────────────────────────
Current Focus:
D2 execution is now centered on completing financial correctness
(Tax model) and preparing the Draft → Final boundary.
UX polish, preview generation, and finalization are explicitly deferred
until tax correctness is achieved.

Toolchain Status (Operational, Confirmed)

• Kotlin 2.x baseline is active and verified via successful build.
• Compose Compiler is applied via the official Kotlin Compose Compiler Plugin.
• Kotlinx Serialization is enabled and validated in the platform module.
• No forced dependency resolution is in use.
• Toolchain is considered stable for D2 execution.

──────────────────────────────────────
D1 — Invoice Workspace (Operational Clarifications)

The Invoice Workspace is the default landing surface in D1 and is treated
as a working desk, not a document viewer.

Operational intent for D1:

• Workspace UI is read‑only but must be structurally complete and domain‑true.
• UI reflects real GST invoice mental flow before interaction is introduced.
• No PDF viewing, printing, or finalization in D1.
• Summary is informational only; terminal gravity is deferred to D2.
• Search is a distinct mode and must be visibly accessible from the Workspace
  at all times.
• Customer selection, line items, logistics, and summary are staged for
  interaction but remain non‑interactive in D1A.

Explicit exclusions in D1:

• No input atoms or autocomplete behaviour.
• No mutation, commands, or draft persistence.
• No challan creation or linkage actions (conceptual slots only).
• No navigation beyond Workspace ↔ Search Mode.


D1 Status:
• D1A — Invoice Workspace layout, semantics, and visual structure are complete and locked.
• D1B — Parties and Line Item backbone validated conceptually and locked.
• D1 introduced no mutation paths and preserved full read-only guarantees.
• D1 is formally complete; no further work may be added to D1.

NOTE (AMENDED):
While D1 was originally scoped as read-only, draft interaction work was
intentionally executed in D2. All mutation paths, draft reducers, and
interactive atoms belong to D2 and do not violate D1 guarantees.

──────────────────────────────────────
D2 — Core Workflows (Operational Clarifications)

D2 introduces interactive draft creation while preserving all domain, replay, and projection laws.
Drafts are explicitly UI-only workflow state and are not domain truth.

D2.1 — Draft Spine (COMPLETE & LOCKED)
• In-memory, single-draft model owned by a Draft Store.
• Draft mutation flows exclusively through Draft Store APIs.
• Draft Reducers remain pure and side-effect free.
• ViewModels coordinate intent but contain no business rules.
• Draft UI State is disposable and never persisted as domain truth.

Status Confirmation:
The Draft Spine has been exercised across multiple complex atoms
(Parties, Line Items, Transportation Mode, Document Type) and is now
considered proven in practice, not theoretical.

D2.2 — Atom-by-Atom UI Enablement (ACTIVE)

D2.2.A — Atom Inventory (Authoritative for D2)

• Atom 1 — Billed To (Customer selection)
  – Autocomplete-backed
  – Draft mutation: billedTo
  – Status: COMPLETE & LOCKED

• Atom 2 — Shipped To (Override from Billed To)
  – Defaults to billedTo when unset
  – Tap-to-edit override
  – Draft mutation: shippedToOverride
  – Status: COMPLETE & LOCKED

• Atom 3 — Line Items
  – Add / edit / remove draft line items
  – Inline editor with Save / Cancel
  – Draft mutation: lineItems[]
  – Status: COMPLETE & LOCKED

• Atom 4 — Transportation Mode
  – Unified transport details (transporter, vehicle, supply date, GR/LR, freight)
  – Whole-block edit semantics
  – Draft mutation: transportDetails
  – Status: COMPLETE & LOCKED

• Atom 5 — Summary (Derived)
  – Subtotal, tax placeholder, grand total
  – Derived exclusively in reducer
  – Status: COMPLETE & LOCKED

• Atom 6.1 — Document Type (Invoice / Challan)
  – Draft-level document type
  – Propagated end-to-end
  – Status: COMPLETE & LOCKED

• Atom 6.2 — Tax Model (GST)
  – CGST / SGST / IGST breakdown
  – DocumentType-aware (Invoice vs Challan)
  – Draft-derived only (reducer-owned)
  – Buyer-state–aware via Customer.stateCode
  – Seller-state temporarily assumed (explicit TODO)
  – Status: COMPLETE & LOCKED

• Atom 1 — Billed To (Customer selection):
  – Draft mutation path implemented via Draft Store.
  – Read path defined via CustomerAutocompleteDataSource (CRUD-backed).
  – Data source reads from a designated read-only Customer CRUD table.
  – ViewModel wiring complete; no replay or projection dependency.
  – Subsequent atoms (Shipped To, Line Items, Freight, Summary) are gated behind Atom 1 completion.
  – Atom 1 is considered complete once UI → ViewModel → Draft Store wiring is functional and visible on screen.

Resolved UX Direction — Autocomplete & Input Interactions (Locked)

Autocomplete behavior for input‑heavy atoms has now been explicitly designed
and is considered directionally locked. This section records execution‑level
UX rules; it does not alter domain, draft, or replay guarantees.

Resolved Interaction Model:
• Autocomplete is typing‑first and power‑user optimized.
• Input fields remain fully editable at all times.
• Suggestions are rendered inline (non‑popup) below the input field.
• Popup‑based components (e.g. DropdownMenu, Popup) are not used for autocomplete.
• Keyboard focus must never be interrupted while typing.
• Keyboard closes only on explicit suggestion selection or user dismissal.
• Suggestions may appear from the first character.
• Suggestions auto‑hide when empty.
• Selection commits value and collapses suggestions deterministically.

Visual & Surface Semantics:
• Autocomplete suggestions are treated as assistive surfaces, not modal pickers.
• Assistive surfaces are visually subordinate to the primary input field.
• Visual hierarchy is expressed via spacing, typography, and elevation first.
• Color usage follows semantic tokens defined in core/theme.
• Raw hex colors are not permitted in UI code.

Execution Notes:
• Autocomplete filtering and ranking logic is owned by screen‑level state
  (ViewModel / reducer), not by UI primitives.
• UI primitives receive pre‑filtered, ordered suggestion lists.
• Result capping and relevance ordering are required for performance and UX
  but are executed upstream.

Status:
• Direction locked.
• UI primitive stabilized.
• Further work limited to visual polish and upstream filtering logic.

Explicit Exclusions in D2:
• No invoice finalization or numbering.
• No authoritative PDF generation (preview-only semantics deferred).
• No cloud sync enablement.
• No multi-draft support.
• No event-sourced customer lifecycle or customer projections in D2.

──────────────────────────────────────
CANONICAL NAVIGATION FLOW (OPERATIONAL, LOCKED)

The application follows a task‑first navigation topology.
This topology is authoritative and must not be re‑routed.
Delivery phases may gate nodes, but must not alter topology.

Default Entry
• App launch lands in Invoice / Challan Workspace (draft‑first).

Primary Modes
• Invoice / Challan Workspace — creation and drafting workspace.
• Search Mode — dedicated recall, comparison, and reuse space.
• Customers — relationship and money management.

Canonical Transitions
• Workspace → Search Mode (explicit user intent).
• Search Mode → Open Document (read‑only snapshot; PDF view deferred to D2).
• Search Mode → Create from existing → Workspace (new draft; gated until D2).
• Workspace → Customers.
• Customers → Add Payment → Customer Ledger.
• Customer Ledger → Open Document (read‑only).
• Back navigation always returns to the originating context.

Document Viewing Law
• Documents are immutable once finalized.
• In D1, documents may be opened only as read‑only data snapshots.
• Authoritative PDF generation occurs only after finalization (D2+).
• All finalized documents are rendered via a single read‑only PDF viewer.
• Documents are never edited in place after finalization.

──────────────────────────────────────
DOCUMENT LINKAGE (INVOICE ↔ CHALLAN) — OPERATIONAL, LOCKED

• Invoices and Challans are independent, immutable documents.
• Linking between documents is explicit and event‑driven.
• Linking never mutates existing documents; it creates new facts.
• One Invoice may link to one or more Challans.
• A Challan may link to at most one Invoice.
• Document linkage is derived into projections for navigation only.
• Linkage must always be visible in search and document views once activated.
• Creation of linkage is gated until D2 workflows.

──────────────────────────────────────
Scope:
• Domain-first design (events, invariants, projections).
• Local database (Room) as the sole source of truth.
• Explicit migrations before schema changes.
• Offline-first sync design (cloud as replication target only).
• Test-first enforcement of domain invariants.
• No speculative UI or UX changes.
• Event Sourcing applied surgically to financial and logistical domain truth only.
• Supporting identity data (e.g. Customers) is managed via CRUD where appropriate.
• Projections treated strictly as rebuildable performance caches.
• Replay-first design with incremental (delta-based) rebuilds for scalability.
• Version-catalog–driven dependency management (no ad-hoc plugin or library versions).
• Platform module is the exclusive owner of persistence technologies (Room, KSP).
• Financial ledger projection pipeline (map → replay → project) implemented and test‑backed.
• Document Index projection pipeline (map → replay → project) implemented and test‑backed.
• PlatformReplayCoordinator is the sole entry point for invoking projection replay and rebuilds.
• Draft workflow state is UI-only, disposable, and excluded from persistence, replay, and sync.

──────────────────────────────────────
Current Working Components:
core/domain/
    ├─ events (Invoice, Payment)
    ├─ invariants (ledger, balance, immutability rules)

platform/database/
    ├─ Room entities & DAOs
    ├─ Explicit migrations (versioned, tested)
    ├─ EventEntity (append-only event store)
    ├─ LedgerBalanceEntity (rebuildable ledger projection)
    ├─ LedgerBalanceDao (projection-only persistence)
    ├─ LedgerProjectionWriter (incremental replay orchestration)
    ├─ DocumentIndexEntity (search/navigation projection)
    ├─ DocumentIndexDao (projection-only persistence)
    ├─ DocumentIndexProjectionWriter (incremental & full replay orchestration)
    ├─ KSP-backed Room configuration (platform-only)
    ├─ CustomerEntity (CRUD-managed customer identity table)
    ├─ CustomerDao (CRUD persistence & read-only queries)

platform/cloud/
    ├─ Sync boundaries & replication logic (no UI coupling)

tests/
    ├─ Domain invariant tests
    ├─ Ledger rebuild tests
    ├─ Migration tests
    ├─ LedgerProjectionWriter tests
    ├─ DocumentIndexProjectionWriter tests

core/replay/
    ├─ Pure replay engine (events → LedgerState)
    ├─ LedgerState (balances + audit entries)
    ├─ DocumentIndexState (canonical document index view)
    ├─ DocumentIndexReplayEngine (pure replay from mutations)
platform/replay/
    ├─ PlatformReplayCoordinator (canonical replay entry point)
    ├─ DefaultPlatformReplayCoordinator (Phase‑1 implementation)
    ├─ PlatformReplayableEvent (event adapter)

feature/invoice/draft/
    ├─ InvoiceDraftUiState (UI-only draft model)
    ├─ InvoiceDraftReducer (pure draft transformations)
    ├─ InvoiceDraftStore (in-memory draft owner)

feature/invoice/ui/
    ├─ InvoiceWorkspaceViewModel (draft orchestration + read/write separation)

feature/invoice/autocomplete/
    ├─ CustomerAutocompleteDataSource (read-only CRUD adapter)

──────────────────────────────────────
Operational Laws (Frozen for Foundation Phases)
• Local database is the single source of truth.
• All financial and document state changes occur via append-only domain events.
• Supporting identity data may change via explicit CRUD within defined boundaries.
• Projections must be fully rebuildable from events.
• No silent data mutation or in-place edits.
• Migrations are mandatory and written before schema changes.
• UI may not compensate for data inconsistency.
• Cloud sync may lag, replay, or fail without corrupting truth.
• Commands express intent; only aggregates may emit domain events.
• Replay explains history; it must never decide or mutate truth.
• Projection tables may be dropped and rebuilt at any time without data loss.
• Performance optimizations must not introduce new sources of truth.
• Build configuration errors are correctness failures, not tooling issues.
• Room, KSP, and migrations must never appear outside the platform module.
• Event storage schema changes require migration tests before merge.
• Projection writers must never be invoked directly outside the PlatformReplayCoordinator.
• Replay execution order is deterministic and centrally enforced.
• Introduction of alternate replay entry points is a constitutional violation.

──────────────────────────────────────
Behavioural Laws for the Assistant:
• Always confirm invariants before proposing data models.
• No Room entities without migration strategy.
• No sync logic without failure and replay semantics.
• Prefer tests and invariants before feature code.
• Stop immediately if correctness is compromised.

──────────────────────────────────────
Current Deliverables (as of Foundation completion):
• Event store (EventEntity + EventDao) locked and tested for replay safety.
• Financial event mapping layer enforced with fail‑loud semantics.
• Deterministic ledger replay engine producing LedgerState.
• Incremental ledger projection writer with embedded cursor strategy.
• Rebuildable ledger balance projection persisted via Room.
• JVM tests covering replay, projection, and failure scenarios.
• Deterministic Document Index replay engine deriving canonical document state.
• Incremental, cursor‑driven Document Index projection writer (idempotent & crash‑safe).
• Rebuildable document index projection persisted via Room.
• JVM tests covering Document Index replay, projection, and failure semantics.
• PlatformReplayCoordinator implemented as the single canonical replay entry point.
• Ledger and Document Index projection writers normalized to a common invocation contract.
