âš ï¸ AUTHORITATIVE CONSTITUTION â€” READ FIRST

This document is the frozen constitutional law of the Verity project.

All sections marked (Frozen) or (Locked) are NONâ€‘NEGOTIABLE.
Nothing in this document may be ignored, weakened, summarized away,
or reinterpreted unless the Core Seed is explicitly reopened.

If any instruction, suggestion, or code conflicts with this seed:
â†’ THIS SEED WINS.

MANDATORY BEHAVIOR FOR ANY CHAT USING THIS SEED:
â€¢ Treat this document as authoritative system law.
â€¢ Ask before assuming anything not explicitly stated.
â€¢ Do not refactor, rename, or restructure unless explicitly requested.
â€¢ Do not introduce abstractions, helpers, or shortcuts.
â€¢ If ambiguity arises, STOP and ask for clarification.
â€¢ If drift is detected, HALT and reassess before proceeding.

This seed exists to prevent architectural erosion.
Violations are correctness defects, not stylistic disagreements.

ğŸ“˜ VERITY â€“ CORE SEED

Authoritative Loading Capsule (Amended & Strengthened)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose

This seed reinitializes the complete philosophical and architectural foundation of Verity.
It never changes unless the global constitution changes.
All other seeds (Operational, Feature, UX, Testing, Phase) must inherit from this one.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

0. Identity

App Name: Verity
Essence: Truth Â· Correctness Â· Clarity Â· Trust
Tone: Professional Â· Modern Â· Calm (not flashy or enterprise gray)
Goal: A long-term, daily-use modern Android billing app.
Distribution: Play Storeâ€“ready, multi-organization SaaS-capable Android app.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Foundational Philosophy (Frozen)

â€¢ Architecture, UX, and correctness matter more than speed.
â€¢ Compose-first, Kotlin-first, testable, scalable.
â€¢ Offline-first â€” local database is the sole source of truth; cloud is a replication and recovery target only.
â€¢ Explicit domain events â€” append-only; no silent mutations.
â€¢ All mutable state is derived from events, never edited in place.
â€¢ Deterministic, rebuildable projections (state must be reproducible from history).
â€¢ Immutability by default â€” invoices, payments, and ledger are never mutated post-finalization.
â€¢ Testing is first-class; domain invariants are enforced through tests, not convention.
â€¢ Modular-by-construction â€” build, dependency, and namespace boundaries are enforced as architectural law.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1A. Domain Causality Laws (Frozen)

â€¢ Commands ask permission.
â€¢ Aggregates decide truth.
â€¢ Events record history.
â€¢ Aggregates create history.
â€¢ Replay interprets history.
â€¢ Projections explain results.
â€¢ Projections present results.
â€¢ No projection is authoritative; deleting any projection must never destroy truth.

Violation of any law is an architectural defect and must stop development until resolved.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

2. Multi-Organization Law (Locked)

â€¢ Must support multiple organizations (not hard-coded for Unitech Machineries).
â€¢ Branding, logo, and tax metadata must be configurable via templates.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

3. Architecture & Structure (Locked)

Top-level packages (ONLY THESE):

app/
â€¢ Application entry, NavHost, DI wiring â€” no business logic.
â€¢ Owns applicationId = com.verity (external identity). Namespace = com.verity.app.

core/
â€¢ theme (colors, typography, motion tokens)
â€¢ ui (primitives, atoms, molecules only)
â€¢ navigation (destinations, routes)
â€¢ formatting (money, dates)
â€¢ utils, result types
â€¢ no feature knowledge.
â€¢ Pure Compose library. No platform, database, or UI state ownership.

features/
â€¢ Each feature isolated â€” Invoice, Search, Customers, Ledger, Payments.
â€¢ Communication only via navigation contracts or IDs.
â€¢ No shared UI, ViewModels, or repositories.
â€¢ Compose-first feature libraries. No Activities, no databases, no cross-feature state.

platform/
â€¢ database (Room + KSP)
â€¢ cloud (Firebase / APIs)
â€¢ workers (WorkManager)
â€¢ device helpers and permissions.
â€¢ Infrastructure-only. Owns Room, KSP, migrations, sync, workers. No UI dependencies.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

3A. Namespace & Module Identity Laws (Frozen)

â€¢ applicationId represents the product identity and is fixed as: com.verity
â€¢ Every module has its own namespace rooted at com.verity.<module>
â€¢ No customer, environment, or developer name may appear in package paths.
â€¢ Organizations exist only as data (OrganizationEntity), never as code structure.
â€¢ Namespace changes after first public release are forbidden.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4. Core Domain Model (Immutable)

â€¢ Invoices = Events
â€¢ Payments = Events
â€¢ Customers = Identities
â€¢ Ledger = Deterministic projection
(Invoices â†’ Debits; Payments â†’ Credits)

Rules:
	â€¢	Invoices immutable once finalized.
	â€¢	Payments always positive, immutable, and reversible only via new entries.
	â€¢	Ledger is read-only and fully rebuildable from events.
	â€¢	Negative balance represents customer credit (advance), never negative payments.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4A. Immutability Laws (Frozen)

â€¢ The events table is append-only.
â€¢ No event may be updated, deleted, or rewritten.
â€¢ All corrections are represented by new compensating events.
â€¢ No migration may alter the meaning of historical events.
â€¢ Projections and drafts are disposable; events are not.
â€¢ Replay is the only valid mechanism to derive state from history.

Any attempt to bypass immutability is a correctness violation.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4C. Financial Truth & Projection Backbone (Locked)

â€¢ Domain financial truth is represented exclusively by immutable events.
â€¢ Ledger balance is a deterministic, rebuildable projection derived from events.
â€¢ Financial meaning is extracted via an explicit mapping layer before replay.
â€¢ Replay engines are pure, deterministic, and sideâ€‘effect free.
â€¢ Projection writers orchestrate incremental replay and atomic persistence.
â€¢ Projection tables embed replay cursors to support incremental catchâ€‘up.
â€¢ Invalid or nonâ€‘interpretable financial history must fail loudly and stop projection.
â€¢ Projections may be dropped and rebuilt without data loss or semantic change.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4D. Event Replay & Projection Infrastructure (Locked)

Verity derives all read models through explicit, deterministic replay pipelines
built on immutable domain events.

Core rules:

â€¢ All projections are derived exclusively from immutable domain events.
â€¢ Replay engines are pure, deterministic, and sideâ€‘effect free.
â€¢ Mapping from raw events to replay inputs is explicit and failâ€‘loud.
â€¢ Projection writers orchestrate replay and persistence but do not interpret domain meaning.
â€¢ Projection writers must be idempotent and safe to rerun after crashes.
â€¢ Projection tables embed replay cursors to support incremental catchâ€‘up.
â€¢ Invalid or nonâ€‘interpretable history must halt projection advancement.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4D-A. Platform Replay Orchestration (Locked)

â€¢ All projection writers must be invoked exclusively via a single
  platform-level replay coordinator.

â€¢ The replay coordinator is the canonical entry point for:
  â€“ Incremental projection replay
  â€“ Full projection rebuilds (where supported)

â€¢ UI layers, features, workers, services, or background jobs must
  never invoke projection writers directly.

â€¢ The replay coordinator defines and enforces deterministic
  projection execution order.

â€¢ Projection writers remain independent, idempotent, and rebuildable;
  the coordinator contains no business logic and no persistence logic.

Violation of this rule is an architectural defect and must halt development.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4E. Canonical Replay Pipeline (Locked)

Every replayable projection in Verity follows this canonical structure:

EventEntity (appendâ€‘only, Room)
   â†“
Platform Adapter (platformâ€‘owned)
   â†“
Event Mapper (coreâ€‘owned)
   â†“
Replay Engine (coreâ€‘owned, pure)
   â†“
Projection State (coreâ€‘owned, immutable)
   â†“
Projection Writer (platformâ€‘owned)
   â†“
Projection Entity / Table (Room, disposable)

Rules:

â€¢ Core must never depend on Room, Android, or platform persistence.
â€¢ Platform may adapt persistence models into coreâ€‘consumable inputs.
â€¢ Replay engines must produce identical output for identical event history.
â€¢ Projection writers are the sole writers of projection tables.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4F. Implemented Projections (Current â€“ Phase 5)

The following replay pipelines are implemented and enforced:

Ledger Projection
â€¢ Financial events mapped via an explicit financial mapping layer.
â€¢ Ledger replay engine computes balances deterministically.
â€¢ Ledger balance persisted as a rebuildable projection.
â€¢ Cursorâ€‘based incremental replay enforced.
â€¢ JVM tests lock replay correctness and projection writer behavior.

Document Index Projection
â€¢ Invoice and Challan lifecycle indexed for search and navigation.
â€¢ Explicit mapping from document events to index mutations.
â€¢ Replay engine derives canonical document index state.
â€¢ Projection writer supports incremental replay and full rebuild.
â€¢ Projection is idempotent, crashâ€‘safe, and cursorâ€‘driven.
â€¢ JVM tests validate replay orchestration and persistence semantics.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4G. Testing & Stability Clarification (Locked)

â€¢ Replay engines are tested in isolation as pure functions.
â€¢ Projection writers are tested using fakes for persistence and mapping.
â€¢ JVM tests must not depend on Android framework classes.
â€¢ Mapper implementation shape (class vs interface) is an architectural decision.
â€¢ Established replay pipelines must not be structurally refactored without
  explicitly reopening the Core Seed.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4B. Aggregate Boundaries (Frozen)

Verity uses explicit aggregate boundaries to enforce correctness and prevent cross-domain mutation.
An aggregate is the smallest unit that enforces its own invariants and emits its own domain events.

Authoritative aggregate list (Phase 5):

â€¢ Customer
  - Identity: customerId
  - Responsibility: customer lifecycle and non-financial metadata

â€¢ Invoice
  - Identity: invoiceId
  - Responsibility: financial debit (service or sale)
  - Emits: InvoiceFinalized, InvoiceCancelled

â€¢ Challan
  - Identity: challanId
  - Responsibility: goods custody / logistical truth
  - Emits: ChallanIssued, ChallanCancelled

â€¢ Payment
  - Identity: paymentId
  - Responsibility: financial credit
  - Emits: PaymentRecorded, PaymentReversed

â€¢ DocumentRelationship
  - Identity: relationshipId
  - Responsibility: explicit, auditable linkage between domain documents
  - Emits: DocumentsLinked (and compensating unlink events if introduced later)

Rules:
â€¢ Aggregates validate commands and decide truth.
â€¢ Aggregates must never read or mutate other aggregates.
â€¢ Cross-aggregate coordination is expressed only via events and references.
â€¢ Ledger, balances, statuses, jobs, drafts, and summaries are NOT aggregates; they are projections or workflow state.
â€¢ Aggregates emit events only after successful invariant validation; drafts and UI state are not events.

Changing aggregate boundaries requires an explicit constitutional amendment.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

5. UI & UX Foundations (Frozen)

â€¢ Compose-first; XML forbidden.
â€¢ Invoice creation is the default primary action.
â€¢ Search is deliberate, not ambient.
â€¢ Fast-entry UX for power users is mandatory.
â€¢ Preview-before-finalize is mandatory.
â€¢ Ledger explains truth; it never edits it.
â€¢ Payments are explicit, never automatic.
â€¢ Motion may acknowledge change but must never carry meaning.
â€¢ Immutability is a user-facing principle â€” truth over illusion.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

6. Coding Interaction Rules (Critical)
	1.	Do not assume new methods, classes, or imports.
	2.	Ask first if something is missing.
	3.	Work on one file at a time.
	4.	No refactors unless explicitly requested.
	5.	Explain reasoning before writing code.
	6.	Prefer minimal, reversible changes.

Violation = stop and reassess.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

6A. Production Code Quality Laws (Frozen)

All code produced for Verity must be productionâ€‘grade and shippable by default.

This is nonâ€‘negotiable.

Rules:
â€¢ Every file must be written as if it will ship to production unchanged.
â€¢ Code must follow consistent structure, naming, and formatting across the entire codebase.
â€¢ Comment style must be uniform: purpose first, then intent, then constraints (where applicable).
â€¢ Comments must explain *why* something exists, not restate what the code does.
â€¢ Public classes and critical functions must have clear, concise KDoc.
â€¢ No experimental, placeholder, or â€œtemporaryâ€ code is allowed without explicit approval.
â€¢ Industryâ€‘standard best practices must be used wherever applicable (Android, Kotlin, architecture).
â€¢ Each file should be readable in isolation and clearly convey its responsibility.
â€¢ Consistency across files is valued more than cleverness or brevity.
â€¢ Build logic (Gradle, catalogs, plugins) is treated as production code and held to the same standard as Kotlin sources.

If a file is not productionâ€‘ready, it must not be written.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

7. Testing & Reliability

â€¢ Each module and feature independently testable.
â€¢ Explicit migrations required for all Room schema changes.
â€¢ Ledger rebuildability tested as a non-negotiable invariant.
â€¢ Domain invariants must have tests before features rely on them.
â€¢ No Firebase listeners or remote triggers in the UI layer.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

7A. Projection Laws (Frozen)

â€¢ Projections are performance optimizations, never sources of truth.
â€¢ All projections must be fully rebuildable from events.
â€¢ Projections may lag behind events but must converge deterministically.
â€¢ UI and business logic must never mutate projections directly.
â€¢ If projections disagree with events, events always win.
â€¢ Loss or corruption of a projection must not cause data loss.

Projection correctness is enforced through replay-based tests.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

8. Stack (Locked)

Jetpack Compose Â· Material 3 (tokens only) Â· Navigation-Compose Â·
ViewModel + StateFlow Â· Room + KSP Â· Coroutines Â· WorkManager Â·
Hilt Â· Gradle Version Catalogs

Forbidden:
XML Â· Fragments Â· LiveData Â· AsyncTask Â· RxJava Â· EventBus Â·
DataBinding Â· Legacy Material 2

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

9. Global UX Laws (Frozen)
	1.	Invoice creation is the default action.
	2.	Search is deliberate, not ambient.
	3.	Ledger explains truth; never edits.
	4.	Payments explicit; never automatic.
	5.	Preview-before-finalize mandatory.
	6.	Fast-entry UX is first-class.
	7.	Immutability is default.
	8.	Search context always visible and resettable.
	9.	Secondary information never steals focus.
	10.	Every screen must be wireframed before code.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

10. Coding Assistant Behaviour

This capsule defines Verityâ€™s law.
Any derived seed (operational, feature, UX, or testing) inherits these rules.
If ambiguity arises, stop and request clarification before proceeding.

â¸»
